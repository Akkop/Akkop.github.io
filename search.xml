<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Servlet规范和Servlet容器</title>
    <url>/1c68dade.html</url>
    <content><![CDATA[<hr>
<ul>
<li>HTTP 服务器调用java类的方法</li>
<li>HTTP 选择Servlet以及Servlet的实例化</li>
</ul>
<span id="more"></span>

<h1 id="Servlet规范和Servlet容器"><a href="#Servlet规范和Servlet容器" class="headerlink" title="Servlet规范和Servlet容器"></a>Servlet规范和Servlet容器</h1><h2 id="HTTP-服务器-怎么调用对应-Java-类的哪个方法？"><a href="#HTTP-服务器-怎么调用对应-Java-类的哪个方法？" class="headerlink" title="HTTP 服务器 怎么调用对应 Java 类的哪个方法？"></a>HTTP 服务器 怎么调用对应 Java 类的哪个方法？</h2><p>❌</p>
<blockquote>
<p>方式：通过一堆if-else进行判断<br>问题：HTTP 服务器的代码跟业务逻辑耦合在一起了，如果新加一个业务方法还要改 HTTP 服务器的代码。</p>
</blockquote>
<p>✔️</p>
<blockquote>
<p>方式：通过接口进行解耦，各种业务类都必须实现这个接口(Servlet 接口)</p>
</blockquote>
<h2 id="HTTP-服务器如何知道由哪个-Servlet-来处理呢？Servlet-又是由谁来实例化呢？"><a href="#HTTP-服务器如何知道由哪个-Servlet-来处理呢？Servlet-又是由谁来实例化呢？" class="headerlink" title="HTTP 服务器如何知道由哪个 Servlet 来处理呢？Servlet 又是由谁来实例化呢？"></a>HTTP 服务器如何知道由哪个 Servlet 来处理呢？Servlet 又是由谁来实例化呢？</h2><p>❌</p>
<blockquote>
<p>方式：使用 HTTP 服务器进行<br>问题：HTTP 服务器 和 业务类耦合</p>
</blockquote>
<p>✔️</p>
<blockquote>
<p>方式：添加 Servlet 容器，Servlet 容器用来加载和管理业务类</p>
</blockquote>
<h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><blockquote>
<p>Servlet 接口是 Servlet 容器跟具体业务类之间的接口。<br>Servlet 接口和 Servlet 容器这一整套规范叫作 Servlet 规范</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res）<span class="keyword">throws</span> ServletException, IOException;</span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    String getServletInfo()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重点方法：service"><a href="#重点方法：service" class="headerlink" title="重点方法：service"></a>重点方法：<em><strong>service</strong></em></h3><p>service的两个参数</p>
<ul>
<li><p>ServletRequest 用来封装请求信息</p>
</li>
<li><p>ServletResponse 用来封装响应信息</p>
</li>
</ul>
<blockquote>
<p>本质上这两个类是对通信协议的封装</p>
</blockquote>
<h3 id="其余方法"><a href="#其余方法" class="headerlink" title="其余方法"></a>其余方法</h3><p>生命周期相关方法：<strong>init</strong> 和 <strong>destroy</strong></p>
<ul>
<li>Servlet 容器在加载 Servlet 类的时候会调用 <strong>init</strong> 方法</li>
<li>Servlet 容器在卸载 Servlet 类的时候会调用 <strong>destroy</strong> 方法</li>
</ul>
<p>Servlet 配置相关方法：<strong>getServletConfig</strong></p>
<ul>
<li>ServletConfig 的作用就是封装 Servlet 的初始化参数</li>
<li>可以在web.xml给 Servlet 配置参数，并在程序里通过 getServletConfig 方法拿到这些参数。</li>
</ul>
<p>Servlet 的 <strong>GenericServlet</strong> 抽象类 和 <strong>HttpServlet</strong> 类</p>
<ul>
<li>GenericServlet 实现了 Servlet 的通用方法 而 HttpServlet 是在 GenericServlet 基础上进行了封装加入了 HTTP 特性</li>
</ul>
<p>HttpServlet 只需要重写 doGet 和 doPost。</p>
<h2 id="Servlet-容器"><a href="#Servlet-容器" class="headerlink" title="Servlet 容器"></a>Servlet 容器</h2><p>整体工作流程</p>
<ol>
<li>客户端发起 HTTP 请求</li>
<li>HTTP 服务器使用 ServletRequest 讲请求封装</li>
<li>调用 Servlet 容器的 service 方法</li>
<li>Servlet 容器，根据请求的 URL 和 Servlet 的映射关系，找到相应的 Servlet</li>
<li>如果 Servlet 还没有被加载，就用反射机制创建这个 Servlet，并调用 Servlet 的 init 方法来完成初始化</li>
<li>调用 Servlet 的 service 方法来处理请求，把 ServletResponse 对象返回给 HTTP 服务器</li>
<li>讲响应返回给客户端</li>
</ol>
<p><strong>Web 应用层级</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| - MyWebApp </span><br><span class="line">| - WEB-INF/web.xml -- 配置文件，用来配置Servlet等 </span><br><span class="line">| - WEB-INF/lib/ -- 存放Web应用所需各种JAR包 </span><br><span class="line">| - WEB-INF/classes/ -- 存放你的应用类，比如Servlet类 </span><br><span class="line">| - META-INF/ -- 目录存放工程的一些信息</span><br></pre></td></tr></table></figure>

<p>Servlet 容器顺序</p>
<ol>
<li>实例化 Servlet</li>
<li>调用 Servlet</li>
</ol>
<p><strong>Servlet 是怎么注册到 Servlet 容器中</strong></p>
<ol>
<li>以 Web 应用程序的方式来部署 Servlet </li>
<li>Servlet 规范里定义了 ServletContext 这个接口来对应一个 Web 应用</li>
<li>Servlet 容器在启动时会加载 Web 应用，并为每个 Web 应用创建唯一的 ServletContext 对象</li>
<li>由于 ServletContext 持有所有 Servlet 实例，你还可以通过它来实现 Servlet 请求的转发。扩展机制</li>
</ol>
<p><strong>扩展机制</strong></p>
<p>Servlet 规范提供了两种扩展机制：</p>
<ul>
<li>Filter  过滤器</li>
<li>Listener 监听器</li>
</ul>
<p><strong>Filter 过滤器的流程</strong></p>
<ol>
<li>Web 应用部署完成</li>
<li>Servlet 容器需要实例化 Filter 并把 Filter 链接成一个 FilterChain。</li>
<li>请求进来，获取第一个 Filter 并调用 doFilter 方法，doFilter 方法负责调用这个 FilterChain 中的下一个 Filter。</li>
</ol>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS简易安装Mysql</title>
    <url>/f6937770.html</url>
    <content><![CDATA[<ul>
<li>删除Mysql配置</li>
<li>安装mysql</li>
<li>远程连接</li>
</ul>
<span id="more"></span>

<h2 id="删除MySQL配置（重要！）"><a href="#删除MySQL配置（重要！）" class="headerlink" title="删除MySQL配置（重要！）"></a>删除MySQL配置（重要！）</h2><blockquote>
<p>rpm -qa | grep -i mysql  查看是否安装mysql<br>yum -y remove MySQL-* 删除mysql<br>find / -name mysql 列出mysql rm -rf 删除mysql文件加<br>rm -rf /etc/my.cnf 删除配置<br>rm -rf /root/.mysql_sercret 删除默认密码</p>
</blockquote>
<hr>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><ol>
<li><p>配置Mysql 8.0安装源<br>sudo rpm -Uvh <a href="https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm">https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm</a></p>
</li>
<li><p>安装Mysql 8.0</p>
<blockquote>
<p>sudo yum –enablerepo=mysql80-community install mysql-community-server</p>
</blockquote>
</li>
<li><p>⭐安装server时如报错 </p>
<blockquote>
<p>All matches were filtered …. mysql-community-server<br>Error: Unable to find a match: mysql-community-server<br>先执行下面两句<br><strong>yum module disable mysql</strong><br><strong>yum -y install mysql-community-server</strong><br>再重新执行第二步骤</p>
</blockquote>
</li>
<li><p>启动mysql服务(这一步要等待一会会)</p>
<blockquote>
<p>sudo service mysqld start</p>
</blockquote>
</li>
<li><p>查看mysql服务运行状态</p>
<blockquote>
<p>service mysqld status</p>
</blockquote>
</li>
<li><p>查看root临时密码</p>
<blockquote>
<p>grep “A temporary password” /var/log/mysqld.log</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A temporary password <span class="keyword">is</span> generated <span class="keyword">for</span> root<span class="variable">@localhost</span>: ilPikNwys1_g</span><br></pre></td></tr></table></figure></li>
<li><p>更改临时密码</p>
<blockquote>
<ol>
<li>mysql -uroot -p</li>
<li>输入临时密码</li>
<li>ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘new password’;</li>
</ol>
</blockquote>
</li>
<li><p>密码的设置有约束,成功设置密码有以下两种方式</p>
<blockquote>
<p>设置符合策略的密码(大小写字母+数据+符号)</p>
<p>密码策略改简单一点</p>
</blockquote>
<p>⭐需要注意的是如果需要变更策略首先需要改一次符合策略的密码(可用如下sql先修改)</p>
<p><strong>ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘Root_12root’ PASSWORD EXPIRE NEVER;</strong></p>
</li>
<li><p>如果不想输入符合策略的密码</p>
<blockquote>
<p>查看当前的密码验证策略(注意密码修改之后才可以查看和第10步修改)</p>
<p>SHOW VARIABLES LIKE ‘validate_password%’;</p>
</blockquote>
</li>
<li><p>策略说明</p>
<blockquote>
<p>validate_password.length 是密码的最小长度，默认是8，我们把它改成6<br>输入：set global validate_password.length=6;<br>validate_password.policy 验证密码的复杂程度，我们把它改成0<br>输入：set global validate_password.policy=0;<br>validate_password.check_user_name 用户名检查，用户名和密码不能相同，我们也把它关掉<br>输入：set global validate_password.check_user_name=off;</p>
</blockquote>
</li>
<li><p>重新设置想要密码</p>
<blockquote>
<p>ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘XXXXXXX’ PASSWORD EXPIRE NEVER;</p>
</blockquote>
</li>
</ol>
<h2 id="连接远程"><a href="#连接远程" class="headerlink" title="连接远程"></a>连接远程</h2><ol>
<li><p>看下默认MySQL用户：</p>
<blockquote>
<p>输入：use mysql;</p>
<p>输入：select host, user, authentication_string, plugin from user;</p>
<p>查询结果有没有百分号root用户</p>
</blockquote>
</li>
<li><p>没有百分号root用户 执行两面两句</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> root@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>; </span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> root@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>有百分号root用户 直接执行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> root@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></table></figure>

<p>然后去 <strong>开放防火墙 3306端口</strong> 这个很重要  我是在腾讯云直接网页端配置了3306.也可以使用命令我就不找了emm</p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat容器的设计</title>
    <url>/210d100c.html</url>
    <content><![CDATA[<hr>
<ul>
<li>容器的层次结构</li>
<li>容器的管理</li>
<li>定位Servlet的过程</li>
<li>PipeLine-valve 管道</li>
</ul>
<span id="more"></span>

<h1 id="Tomcat-容器的设计"><a href="#Tomcat-容器的设计" class="headerlink" title="Tomcat 容器的设计"></a>Tomcat 容器的设计</h1><h2 id="容器的层次结构"><a href="#容器的层次结构" class="headerlink" title="容器的层次结构"></a>容器的层次结构</h2><p>层级由高到低 1 - 4 展示如下</p>
<ol>
<li>Engine [ 表示引擎 ]  </li>
<li>Host [ 表示一个虚拟主机/站点 ]</li>
<li>Context  [ 表示一个 Web 应用程序 ]</li>
<li>Wrapper [ 表示一个 Servlet ]<br>👆🏻<br>👇🏻</li>
</ol>
<ul>
<li>一个 Web 应用程序可以有多个 Servlet</li>
<li>一个虚拟机可以部署多个 Web 应用程序</li>
<li>一个 Service 只能有一个 Engine</li>
<li>一个 Server 可以有多个 Service</li>
</ul>
<p><img src="/210d100c/tu1.png" alt="tu1.png"></p>
<p>⭐4 种容器不是平行关系，而是父子关系，而设计这么多容器的目的是通过分层架构，使 Servlet 容器更具灵活性</p>
<h2 id="Tomcat-容器对容器的管理"><a href="#Tomcat-容器对容器的管理" class="headerlink" title="Tomcat 容器对容器的管理**"></a>Tomcat 容器对容器的管理**</h2><p>容器之间是父子关系，即树形结构，即 TomCat 可使用组合模式来进行管理的容器的</p>
<p>具体组合模式的实现</p>
<ul>
<li>所有容器实现 Container 接口<blockquote>
<p>用户对单容器对象和组合容器对象的使用具有一致性<br>单容器对象指的是最底层的 Wrapper，组合容器对象指的是上面的 Context、Host 或者 Engine</p>
</blockquote>
</li>
</ul>
<p>Container 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Container container)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">findChild</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⭐Container 接口 提供了对父容器，子容器的操作，同时扩展了 Lifecycle，而 Lifecycle 是用来统一管理各组件的生命周期</p>
<h2 id="请求定位-Servlet-的过程"><a href="#请求定位-Servlet-的过程" class="headerlink" title="请求定位 Servlet 的过程"></a>请求定位 Servlet 的过程</h2><p>❓<strong>疑问点</strong></p>
<blockquote>
<p>Tomcat 是怎么确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的？</p>
</blockquote>
<p>❗<strong>答案</strong></p>
<blockquote>
<p>Tomcat 是用 Mapper 组件来完成这个任务的。</p>
<p>Mapper 组件的功能就是将用户请求的 URL 定位到一个 Servlet</p>
</blockquote>
<h3 id="Mapper-组件"><a href="#Mapper-组件" class="headerlink" title="Mapper 组件"></a>Mapper 组件</h3><p>Mapper 组件的工作原理</p>
<ul>
<li>Mapper 组件里保存了 Web 应用的配置信息 ( 容器组件与访问路径的映射关系 )</li>
</ul>
<p><strong>首先，根据协议和端口号选定 Service 和 Engine</strong></p>
<blockquote>
<p>Tomcat 的每个连接器都监听不同的端口，而连接器属于一个 Service 组件<br>Service 组件中包含了多个连接器和一个容器组件<br>一个容器组件具体体现就是 Engine 引擎<br>即Service 组件确认 等于 Engine 引擎确认</p>
</blockquote>
<p><strong>根据域名选定 Host</strong></p>
<blockquote>
<p>Mapper 组件通过 URL 中的域名去查找相应的 Host 容器</p>
</blockquote>
<p><strong>根据 URL 路径找到 Context 组件</strong></p>
<blockquote>
<p>Host 确定以后，Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径</p>
</blockquote>
<p><strong>最后，根据 URL 路径找到 Wrapper（Servlet）</strong></p>
<blockquote>
<p>Context 确定后，Mapper 再根据web.xml中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet。</p>
</blockquote>
<h2 id="Pipeline-Valve-管道"><a href="#Pipeline-Valve-管道" class="headerlink" title="Pipeline-Valve 管道"></a>Pipeline-Valve 管道</h2><p>上述的 Mapper 组件是告诉我们怎么找到 Servlet，然后 Servlet 去做请求</p>
<p>⭐<strong>而实际上这个查找路径上的父子容器都会对请求做一些处理，各容器处理事务遵循责任链模式</strong></p>
<ul>
<li>连接器中的 Adapter 会调用容器的 Service 方法来执行 Servlet</li>
<li>最先拿到请求的是 Engine 容器，对请求做一些处理后，会把请求传给自己子容器 Host 继续处理，依次类推</li>
<li>最后交由 Wrapper 容器，Wrapper 调用最终的 Servlet 来处理</li>
</ul>
<p>👐🏻<strong>Pipeline-Valve 是责任链模式</strong></p>
<blockquote>
<p>责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Valve 是一个处理点 可以想象一下链表，invoke 就是处理，通过 getNext 和 setNext 组成一个链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pipeline</span> <span class="keyword">extends</span> <span class="title">Contained</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addValve</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getBasic</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBasic</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pipeline 中 维护了 Valve 链表，并且其中并没有 invoke 方法，这是因为实际出发还是在 Valve 中的 invoke中，Valve 完成自己的处理后，调用getNext.invoke来触发下一个 Valve 调用。</p>
<hr>
<p>但是上述显的 Pipeline 并没有发挥作用，Pipeline 每个容器都有一个，其中getFirst 和 getBasic 就是来串联 不同容器的，他们分别可以取得 Valve 的第一个节点和最后一个节点 如下图所示</p>
<p><img src="/210d100c/tu2.png" alt="tu2.png"></p>
<p>⭐整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve</p>
<p>⭐Wrapper 容器的最后一个 Valve 会创建一个 Filter 链，并调用 doFilter 方法，最终会调到 Servlet 的 service 方法。</p>
<h3 id="Valve-和-Filter"><a href="#Valve-和-Filter" class="headerlink" title="Valve 和 Filter"></a>Valve 和 Filter</h3><ul>
<li>Valve 是 Tomcat 的私有机制，与 Tomcat 的基础架构 /API 是紧耦合的。Servlet API 是公有的标准，所有的 Web 容器包括 Jetty 都支持 Filter 机制。</li>
<li> Valve 工作在 Web 容器级别，拦截所有应用的请求；而 Servlet Filter 工作在应用级别，只能拦截某个 Web 应用的所有请求。如果想做整个 Web 容器的拦截器，必须通过 Valve 来实现。</li>
</ul>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat基础</title>
    <url>/530cfffd.html</url>
    <content><![CDATA[<hr>
<ul>
<li>Web 容器是什么</li>
<li>Cookie</li>
<li>Session</li>
</ul>
<span id="more"></span>

<h1 id="Tomcat基础"><a href="#Tomcat基础" class="headerlink" title="Tomcat基础"></a>Tomcat基础</h1><h2 id="Web-容器是什么"><a href="#Web-容器是什么" class="headerlink" title="Web 容器是什么"></a>Web 容器是什么</h2><ul>
<li>Servlet 是可以视作没有 main 方法的 java 程序，没有 mian 方法需要部署到 Servlet 容器中，由容器来实例化并调用Servlet</li>
<li>为了方便使用，他们需要具有 HTTP 服务器功能</li>
<li>Tomcat 或者 Jetty 就是 HTTP 服务器 + Servlet 容器</li>
<li>Web 容器 = HTTP 服务器 + Servlet 容器 </li>
</ul>
<blockquote>
<p>如今的 SpringBoot 是内嵌的 Web 容器(Tomcat)，因为当前大环境为微服务(将大而全的单体应用拆分成一个个功能单一的微服务)，这也就需要更多的 Web 容器来启动，自然需要轻量级的 Web 容器，以减少资源的消耗，降低部署的成本，而选择内嵌，降低应用部署的复杂度。</p>
</blockquote>
<h2 id="怎么学习-Web-容器"><a href="#怎么学习-Web-容器" class="headerlink" title="怎么学习 Web 容器"></a>怎么学习 Web 容器</h2><p><strong>HTTP 的本质</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP 协议是浏览器与服务器之间的数据传送协议</span><br><span class="line">HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式</span><br></pre></td></tr></table></figure>

<p>获取远端 HTTP 服务器的数据时</p>
<ol>
<li>与 HTTP 服务器建立 Socket 连接。 ip + 端口</li>
<li>生成请求数据并通过Socket发送出去</li>
</ol>
<p><strong>HTTP 协议做的事情</strong></p>
<ul>
<li>获取还是提交内容</li>
<li>想要的内容是什么</li>
<li>这些内容以一种什么样的格式放到请求</li>
</ul>
<p><strong>HTTP 工作原理</strong></p>
<ol>
<li>用户发起请求_输入网址回车</li>
<li>浏览器发起 TCP 请求连接_经过 TCP 三次握手建立连接</li>
<li>服务器接收并建立连接</li>
<li>浏览器生成 HTTP 格式的数据包</li>
<li>浏览器发送HTTP 格式的请求数据包</li>
<li>服务器解析 HTTP 格式的数据包_得知客户端的意图</li>
<li>服务器执行请求</li>
<li>服务器生成 HTTP 格式的数据包</li>
<li>发送响应数据包</li>
<li>浏览器解析 HTTP 格式的数据包</li>
<li>浏览器呈现 HTML 响应给用户</li>
</ol>
<p><strong>做了哪些事情</strong></p>
<ul>
<li>Tomcat 将 HTTP 请求数据字节解析成 Request 对象</li>
<li>Request 对象 封装了 HTTP 所有的请求信息,此后交给 Web 应用处理</li>
<li>处理后得到 Response 对象</li>
<li>Tomcat 将 Response 对象转成 HTTP 格式得响应数据并返回给浏览器</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><strong>什么是Cookie</strong></p>
<ul>
<li>Cookie 是 HTTP 报文得一个请求头</li>
<li>Cookie 本质上就是一份存储在用户本地的文件，里面包含了每次请求中都需要传递的信息</li>
<li>服务器可以通过读取 Cookie 请求头就知道用户是谁(用户的标识信息)</li>
</ul>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><blockquote>
<p>好处只发送 Sessoion ID 相对安全，节省网络流量，重点是不需要在 Cookie 中保存大量用户信息。<br><strong>Session和Cookie的关系</strong></p>
</blockquote>
<ul>
<li>Cookie 是明文保存，是存在隐患得，Session 是保存在服务器上得，里面保存着用户得状态。</li>
<li>当用户请求到来时，服务端可以通过 Cookie 把用户的请求和用户的 Session 对应起来</li>
<li>浏览器在 Cookie 中填充了一个 Session ID 之类的字段用来标识请求。</li>
</ul>
<p><strong>Session的创建</strong></p>
<ol>
<li>浏览器发起请求 服务器 创建 Session，生成唯一 Session ID 给浏览器带回去。</li>
<li>浏览器发起请求 ，服务器依据带来得 SessionID 找对对应 Session，找到session后 就可以获取或者添加内容</li>
</ol>
<p><strong>Tomcat 对 Session 得处理</strong></p>
<ul>
<li>Session 有过期时间，因此 Tomcat 会开启后台线程定期轮询，如果 Session 过期就会将 Session 失效掉。</li>
<li>使用长连接的 HTTP 协议，会在响应头加入 Connection:keep-alive</li>
</ul>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat连接器的设计</title>
    <url>/d2d77b8f.html</url>
    <content><![CDATA[<hr>
<ul>
<li>Tomcat 总体架构</li>
<li>Tomcat 支持的IO模型和应用层协议</li>
<li>连接器的子模块</li>
</ul>
<span id="more"></span>

<h1 id="Tomcat连接器的设计"><a href="#Tomcat连接器的设计" class="headerlink" title="Tomcat连接器的设计"></a>Tomcat连接器的设计</h1><h2 id="Tomcat-总体架构"><a href="#Tomcat-总体架构" class="headerlink" title="Tomcat 总体架构"></a>Tomcat 总体架构</h2><p>Tomcat 要实现 <em><strong>2 个核心功能</strong></em>：</p>
<blockquote>
<p>处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。<br>加载和管理 Servlet，以及具体处理 Request 请求。</p>
</blockquote>
<p>对应2个核心功能 Tomcat 设计的组件</p>
<blockquote>
<p>连接器（connector）👈  <strong>对外交流(本节内容)</strong><br>容器（container）👈 对内处理</p>
</blockquote>
<h2 id="Tomcat-支持的多种-I-O-模型和应用层协议"><a href="#Tomcat-支持的多种-I-O-模型和应用层协议" class="headerlink" title="Tomcat 支持的多种 I/O 模型和应用层协议"></a>Tomcat 支持的多种 I/O 模型和应用层协议</h2><p>⭐连接器是对外的 应对的就是IO 协议等等</p>
<p><strong>Tomcat 支持的 I/O 模型有：</strong></p>
<ul>
<li>NIO：非阻塞 I/O，采用 Java NIO 类库实现。</li>
<li>NIO.2：异步 I/O，采用 JDK 7 最新的 </li>
<li>NIO.2 类库实现。APR：采用 Apache 可移植运行库实现，是 C/C++ 编写的本地库。</li>
</ul>
<p><strong>Tomcat 支持的应用层协议有：</strong></p>
<ul>
<li>HTTP/1.1：这是大部分 Web 应用采用的访问协议。</li>
<li>AJP：用于和 Web 服务器集成（如 Apache）。</li>
<li>HTTP/2：HTTP 2.0 大幅度的提升了 Web 性能。</li>
</ul>
<p>⭐<em><strong>由于 Tomcat 需要 支持多种 I/O 模型和应用层协议，就需要多种的连接器了。</strong></em></p>
<blockquote>
<p>Tomcat 实例 包裹 连接器（connector）容器（container） 等于 Service 组件。<br>Tomcat 实例 有多个连接器和一个容器</p>
</blockquote>
<p><img src="/d2d77b8f/tu1.png" alt="tu1.png"></p>
<p><em><strong>连接器与容器之间通过标准的 ServletRequest 和 ServletResponse 通信</strong></em></p>
<p><strong>连接器</strong></p>
<blockquote>
<p>连接器对 Servlet 容器屏蔽了协议及 I/O 模型等的区别<br>在容器中获取到的都是一个标准的 ServletRequest 对象</p>
</blockquote>
<p><strong>连接器工作流程</strong>：</p>
<ul>
<li>监听网络端口</li>
<li>接受网络连接请求</li>
<li>读取网络请求字节流</li>
<li>根据具体应用层协议（HTTP/AJP）解析字节流，生成统一的 Tomcat Request 对象</li>
<li>将 Tomcat Request 对象转成标准的 ServletRequest</li>
<li>调用 Servlet 容器，得到 ServletResponse</li>
<li>将 ServletResponse 转成 Tomcat Response 对象</li>
<li>将 Tomcat Response 转成网络字节流</li>
<li>将响应字节流写回给浏览器</li>
</ul>
<h2 id="连接器的子模块"><a href="#连接器的子模块" class="headerlink" title="连接器的子模块"></a>连接器的子模块</h2><p>连接器需要完成 3 个高内聚的功能：</p>
<ul>
<li>网络通信。</li>
<li>应用层协议解析。</li>
<li>Tomcat Request/Response 与 ServletRequest/ServletResponse 的转化。</li>
</ul>
<p>对应这三块 分别对应三个组件 组件之间通过抽象接口交互</p>
<ul>
<li>Endpoint  网络通信</li>
<li>Processor  应用层协议解析</li>
<li>Adapter</li>
</ul>
<p>模块工作分工如下：</p>
<ul>
<li>Endpoint 负责提供字节流给 Processor， <strong>Socket</strong></li>
<li>Processor 负责提供 Tomcat Request 对象给 Adapter， <strong>Tomcat Request</strong></li>
<li>Adapter 负责提供 ServletRequest 对象给容器。  <strong>ServletRequest</strong></li>
</ul>
<p>😈大致外部请求到容器的流程<br><img src="/d2d77b8f/tu2.png" alt="tu2.png"></p>
<p><strong>I/O</strong> <strong>模型和应用层协议可以自由组合</strong></p>
<blockquote>
<p>于是网络通信（Endpoint）和应用层协议解析（Processor）放在一起有了 ProtocolHandler 接口各种协议和通信模型的组合</p>
</blockquote>
<p><strong>ProtocolHandler 组件</strong></p>
<p>由于协议和IO都可以自由搭配的，所以 协议和 IO 需要一起考虑，于是便封装了 协议和 IO 的变化点，产生了 ProtocolHandler 的接口<br>Tomcat 设计了一系列抽象基类来封装这些稳定的部分 如下是对协议层的抽象<br><img src="/d2d77b8f/tu3.png" alt="tu3.png"><br>⭐<strong>总结整体的流程如下图</strong><br><img src="/d2d77b8f/tu4.png" alt="tu4.png"></p>
<p>接下来说的是一下三点的工作原理</p>
<ul>
<li>Endpoint  网络通信</li>
<li>Processor 应用层协议解析</li>
<li>Adapter</li>
</ul>
<p><strong>Endpoint</strong>网络通信</p>
<hr>
<blockquote>
<ol>
<li>Endpoint 是通信端点，是通信监听的接口<br>是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 Endpoint 是用来实现 TCP/IP 协议的。</li>
</ol>
</blockquote>
<hr>
<blockquote>
<ol start="2">
<li>AbstractEndpoint 是 Endpoint 的抽象，他有两个重要的子组件：<strong>Acceptor</strong> 和 <strong>SocketProcessor</strong>。</li>
</ol>
</blockquote>
<ul>
<li>Acceptor 用于监听 Socket 连接请求</li>
<li>SocketProcessor 用于处理接收到的 Socket 请求，它实现 Runnable 接口，在 run 方法里调用协议处理组件 Processor 进行处理.</li>
<li>SocketProcessor 为了提高处理能力，SocketProcessor 被提交到线程池来执行。而这个线程池叫作执行器（Executor)</li>
</ul>
<hr>
<p><img src="/d2d77b8f/tu5.png" alt="tu5.png"></p>
<p>⭐如上图:Endpoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 run 方法会调用 Processor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法。</p>
<p><strong>Processor</strong>应用层协议解析</p>
<ul>
<li>Processor 接收来自 Endpoint 的 Socket</li>
<li>读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理</li>
<li>Processor 是对应用层协议的抽象。</li>
</ul>
<p><strong>Adapter 组件</strong></p>
<p><strong>ProtocolHandler 接口负责解析请求并生成 Tomcat Request 类</strong></p>
<ul>
<li>Tomcat Request 不是标准 ServletRequest 需要转换 这个工作是  <strong>CoyoteAdapter</strong> 完成的</li>
<li>连接器调用 <strong>CoyoteAdapter</strong> 的 sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 service 方法。</li>
</ul>
<p><strong>连接器工作流程</strong></p>
<ul>
<li>Endpoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理</li>
<li>SocketProcessor 的 run 方法会调用 Processor 组件去解析应用层协议</li>
<li>Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法。</li>
</ul>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS Redis安装</title>
    <url>/2e20d1b4.html</url>
    <content><![CDATA[<hr>
<ul>
<li>查看 Centos 版本</li>
<li>添加EPEL仓库</li>
<li>更新yum源</li>
<li>安装redis</li>
<li>修改配置</li>
<li>连接redis</li>
</ul>
<span id="more"></span>

<h3 id="查看-Centos-版本"><a href="#查看-Centos-版本" class="headerlink" title="查看 Centos 版本"></a>查看 Centos 版本</h3><hr>
<blockquote>
<p>cat /etc/redhat-release</p>
</blockquote>
<h3 id="添加EPEL仓库-自由开源的附加软件包仓库"><a href="#添加EPEL仓库-自由开源的附加软件包仓库" class="headerlink" title="添加EPEL仓库 (自由开源的附加软件包仓库)"></a>添加EPEL仓库 (自由开源的附加软件包仓库)</h3><hr>
<blockquote>
<p>sudo yum install epel-release</p>
</blockquote>
<h3 id="更新yum源"><a href="#更新yum源" class="headerlink" title="更新yum源"></a>更新yum源</h3><hr>
<blockquote>
<p>sudo yum update</p>
</blockquote>
<h3 id="安装-redis"><a href="#安装-redis" class="headerlink" title="安装 redis"></a>安装 redis</h3><hr>
<blockquote>
<p>yum install redis</p>
</blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><hr>
<blockquote>
<p>systemctl start redis</p>
</blockquote>
<h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><hr>
<blockquote>
<p>systemctl enable redis</p>
</blockquote>
<h3 id="查看是否启动"><a href="#查看是否启动" class="headerlink" title="查看是否启动"></a>查看是否启动</h3><hr>
<blockquote>
<p>sudo systemctl status redis</p>
</blockquote>
<p>⭐ 到这里位置服务端的 redis 已经启动好了。接下来需要配置的是远程连接。</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><hr>
<blockquote>
<ol>
<li>vim /etc/redis.conf</li>
<li>注释掉 bind 127.0.0.1 启用远程连接</li>
<li>解开注释 # requirepass foobared 将 foodared 替换成自己的密码 启用密码</li>
</ol>
</blockquote>
<h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><hr>
<p>可以通过对应平台的防火墙进行设置<br><img src="/2e20d1b4/tu1.png" alt="tu1.png"></p>
<p>可以通过命令设置防火墙</p>
<ul>
<li>sudo firewall-cmd –add-port=6379/tcp –permanent </li>
<li>sudo firewall-cmd –reload </li>
</ul>
<h3 id="重启-redis"><a href="#重启-redis" class="headerlink" title="重启 redis"></a>重启 redis</h3><blockquote>
<p>systemctl restart redis</p>
</blockquote>
<h3 id="连接成功"><a href="#连接成功" class="headerlink" title="连接成功"></a>连接成功</h3><hr>
<p><img src="/2e20d1b4/tu2.png" alt="tu2.png"></p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识</title>
    <url>/b37d654d.html</url>
    <content><![CDATA[<hr>
<ul>
<li>redis 特性</li>
<li>redis 基础命令</li>
<li>数据类型 - 字符串类型</li>
<li>数据类型 - 散列类型</li>
<li>数据类型 - 列表类型</li>
<li>数据类型 - 集合类型</li>
<li>数据类型 - 有序集合类型</li>
</ul>
<span id="more"></span>

<h2 id="Redis的特性"><a href="#Redis的特性" class="headerlink" title="Redis的特性"></a>Redis的特性</h2><p>Redis 是远程字典服务器，是以字典结构存储数据，允许其他应用通过 TCP 协议读写字典内容</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><hr>
<p>Redis 支持的键值类型如下</p>
<ul>
<li>字符串类型</li>
<li>散列类型</li>
<li>列表类型</li>
<li>集合类型</li>
<li>有序集合类型</li>
</ul>
<h3 id="内存存储和持久化"><a href="#内存存储和持久化" class="headerlink" title="内存存储和持久化"></a>内存存储和持久化</h3><hr>
<p>Redis 的数据都是存储在内存中</p>
<blockquote>
<p>优点: 读写比之读写硬盘快了非常多<br>缺点: 程序退出,内存数据丢失</p>
</blockquote>
<p><strong>Redis 提供了持久化支持，内存中的数据异步写入硬盘，同时不影响继续提供服务</strong></p>
<h3 id="Redis-功能丰富"><a href="#Redis-功能丰富" class="headerlink" title="Redis 功能丰富"></a>Redis 功能丰富</h3><hr>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Redis 是作为数据库开发的，但可以作为缓存，队列等等</span><br><span class="line">Redis 可以为每个键设置生存时间(TTL)	,到期自动删除(可作为缓存)</span><br><span class="line">Redis 可以限定数据占用的最大内存空间，数据达到空间限制后，按照规则删除</span><br><span class="line">Redis 的列表类型键可以用来实现队列，并且支持阻塞式读取</span><br><span class="line">Redis 支持“发布/订阅”的消息模式， 可以基于此构建聊天室等系统</span><br></pre></td></tr></table></figure>

<h2 id="Redis-命令行客户端"><a href="#Redis-命令行客户端" class="headerlink" title="Redis 命令行客户端"></a>Redis 命令行客户端</h2><h3 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h3><hr>
<p>通过 <strong>redis-cli</strong> 向 Redis 发送命令有两种方式</p>
<ol>
<li>将命令作为 redis-cli 的参数执行 如: redis-cli -h 127.0.0.1 -p 6379</li>
<li>不附带参数运行redis-cli 如ping 如 ECHO hi</li>
</ol>
<h3 id="命令返回值"><a href="#命令返回值" class="headerlink" title="命令返回值"></a>命令返回值</h3><hr>
<p><strong>命令的返回值有5种类型</strong></p>
<ol>
<li>状态回复<ul>
<li>如使用 SET 设置了某个键，Redis 回复 OK</li>
</ul>
</li>
<li>错误回复<ul>
<li>如命令不存在或命令格式有错误等情况时返回</li>
</ul>
</li>
<li>整数回复<ul>
<li>如递增键值的 INCR 命令会以整数形式返回递增后的键值，又如获取数据库中键的个数 DBSIZE 命令</li>
</ul>
</li>
<li>字符串回复<ul>
<li>如请求一个字符串类型键的键值，字符串回复以双引号包裹</li>
<li>特殊情况下无键值  nil</li>
</ul>
</li>
<li>多行字符串回复<ul>
<li>请求一个非字符串类型键的元素 列表时就会收到多行字符串回复</li>
<li>如 KEYS ＊</li>
</ul>
</li>
</ol>
<h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><p>Redis 的数据库是从0-15标识<br>Redis 默认有16个数据库 可以使用select 1-15<br>Redis 之间并不是完全隔离的 如使用 FLUSHALL 会清空所有数据库的数据</p>
<h2 id="Redis-的基础命令"><a href="#Redis-的基础命令" class="headerlink" title="Redis 的基础命令"></a>Redis 的基础命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>KEYS pattern</td>
<td>获得符合规则的键名列表</td>
</tr>
<tr>
<td>SET key value</td>
<td>设置键值</td>
</tr>
<tr>
<td>KEYS *</td>
<td>查看所有键</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>判断键是否存在 存在返回1 否则返回0</td>
</tr>
<tr>
<td>DEL key [key …]</td>
<td>删除一个或多个键，返回删除数量</td>
</tr>
<tr>
<td>TYPE key</td>
<td>获得所有键值的类型</td>
</tr>
</tbody></table>
<ul>
<li>[ keys * ] 是遍历所有键，当键数量多的时候会影响性能</li>
</ul>
<h2 id="数据类型-字符串类型"><a href="#数据类型-字符串类型" class="headerlink" title="数据类型 - 字符串类型"></a>数据类型 - 字符串类型</h2><p>字符串类型是最基础的数据类型，能够存储任何形式的字符串，如二进制，邮箱，json，图片。<br>字符串类型最大可以存储 512M<br><strong>字符串类型是其他四种类型的基础</strong></p>
<p>赋值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> key hello</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; set key hello<br>OK</p>
</blockquote>
<hr>
<p>取值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> key</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; set key hello<br>OK<br>127.0.0.1:6379&gt; get key<br>“hello”</p>
</blockquote>
<hr>
<p>取值 <strong>当键不存在 返回 nil</strong></p>
<blockquote>
<p>127.0.0.1:6379&gt; get aakkakaa<br>(nil)</p>
</blockquote>
<hr>
<p>增加指定的整数（num 为数量）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">incrby key num</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; get akk<br>“1”<br>127.0.0.1:6379&gt; incrby akk 2<br>(integer) 3<br>127.0.0.1:6379&gt; get akk<br>“3”</p>
</blockquote>
<hr>
<p>减少指定的整数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">decrby key num</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; get akk<br>“3”<br>127.0.0.1:6379&gt; DECRBY akk 3<br>(integer) 0<br>127.0.0.1:6379&gt; get akk<br>“0”</p>
</blockquote>
<hr>
<p>自增1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; get akk<br>“1”<br>127.0.0.1:6379&gt; incr akk<br>(integer) 2<br>127.0.0.1:6379&gt; get akk<br>“2”</p>
</blockquote>
<hr>
<p>自减1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">decr key</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; get akk<br>“2”<br>127.0.0.1:6379&gt; DECR akk<br>(integer) 1<br>127.0.0.1:6379&gt; get akk<br>“1”</p>
</blockquote>
<hr>
<p>增加指定浮点数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">incrbyfloat key <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; get akk<br>“0.5”<br>127.0.0.1:6379&gt; incrbyfloat akk 0.66<br>“1.16”<br>127.0.0.1:6379&gt; get akk<br>“1.16”</p>
</blockquote>
<hr>
<p>向尾部追加值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">APPEND key <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; get akk<br>“10.111”<br>127.0.0.1:6379&gt; APPEND akk 66<br>(integer) 8<br>127.0.0.1:6379&gt; get akk<br>“10.11166”</p>
</blockquote>
<hr>
<p>获取字符串长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; get akk<br>“10.11166”<br>127.0.0.1:6379&gt; strlen akk<br>(integer) 8</p>
</blockquote>
<hr>
<p>同时获取多个键值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MGET KEY [key ...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; keys *<br>“key”<br>“pushkey”<br>“akk”<br>“1”<br>127.0.0.1:6379&gt; mget key akk<br>“hello”<br>“1.16”</p>
</blockquote>
<hr>
<p>同时设置多个键值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mset key <span class="keyword">value</span> [key <span class="keyword">value</span> ...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; mset key1 v2 key2 v2 key3 v3<br>OK<br>127.0.0.1:6379&gt; mget key1 key2 key3<br>“v2”<br>“v2”<br>“v3”</p>
</blockquote>
<hr>
<h2 id="数据类型-散列类型"><a href="#数据类型-散列类型" class="headerlink" title="数据类型 - 散列类型"></a>数据类型 - 散列类型</h2><p>散列类型( hash )  由  **存储字段(field) ** 和 <strong>字段值映射</strong>组成<br>Redis 不支持数据类型嵌套,如不能集合中嵌套散列表</p>
<p><strong>散列表适用环境</strong><br>⭐散列表适合存储对象</p>
<blockquote>
<p>使用对象类别和ID构成键名,使用字段标识对象的属性,而字段值和存储属性值</p>
</blockquote>
<p><img src="/b37d654d/tu1.png" alt="tu1.png"></p>
<p>赋值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HSET key field <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; hset car color red<br>(integer) 1<br>127.0.0.1:6379&gt; hset car name QQ<br>(integer) 1<br>127.0.0.1:6379&gt; hset car price 100<br>(integer) 1</p>
</blockquote>
<hr>
<p>取值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HGET key field <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; hget car name<br>“QQ”</p>
</blockquote>
<hr>
<p>同时设置多个键值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HMSET key field <span class="keyword">value</span>[field <span class="keyword">value</span> ...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; hmset car2.0 color black name QQ2.0 price 200<br>OK</p>
</blockquote>
<hr>
<p>同时取多个值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HMGET key field <span class="keyword">value</span>[field <span class="keyword">value</span> ...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; hmget car2.0 color name price<br>“black”<br>“QQ2.0”<br>“200”</p>
</blockquote>
<hr>
<p>取得某个散列全部键值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HGETALL KEY</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; HGETALL car2.0<br>“color”<br>“black”<br>“name”<br>“QQ2.0”<br>“price”<br>“200</p>
</blockquote>
<hr>
<p>判断字段是否存在</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HEXISTS KEY FIELD</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; HEXISTS car name<br>(integer) 1<br>127.0.0.1:6379&gt; HEXISTS car nane<br>(integer) 0</p>
</blockquote>
<hr>
<p>当字段不存在时赋值 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HSETNX key field <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; HGETALL car<br>“color”<br>“red”<br>“name”<br>“TT”<br>“price”<br>“100”<br>127.0.0.1:6379&gt; HSETNX car name UU<br>(integer) 0<br>127.0.0.1:6379&gt; HGET car name<br>“TT”<br>127.0.0.1:6379&gt; HSET car name UU<br>(integer) 0<br>127.0.0.1:6379&gt; HGET car name<br>“UU”<br>127.0.0.1:6379&gt; </p>
</blockquote>
<hr>
<p>增加数字 </p>
<p>❗散列没有 INCRBY 但是可以通过HINCRBY 指定 1来实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; hget car price<br>“100”<br>127.0.0.1:6379&gt; HINCRBY car price 400<br>(integer) 500<br>127.0.0.1:6379&gt; hget car price<br>“500”</p>
</blockquote>
<hr>
<p>删除字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; HDEL car name color<br>(integer) 2<br>127.0.0.1:6379&gt; HGETALL car<br> “price”<br> “500”</p>
</blockquote>
<hr>
<p>只获取字段名或字段值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HKEYS key</span><br><span class="line">HVALS KEY</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; hkeys car<br> “price”<br>127.0.0.1:6379&gt; HVALS car<br> “500”</p>
</blockquote>
<hr>
<p>获取字段数量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure>
<p>127.0.0.1:6379&gt; HKEYS car<br> “price”<br> “name”<br>127.0.0.1:6379&gt; HLEN car<br>(integer) 2</p>
<h2 id="数据类型-列表类型"><a href="#数据类型-列表类型" class="headerlink" title="数据类型 - 列表类型"></a>数据类型 - 列表类型</h2><p>列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素， </p>
<p>或者获得列表的某一个片段。 </p>
<p>列表类型内部是使用双向链表（double linked list）实现的</p>
<hr>
<p>向列表两端增加元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- LPUSH 命令用来向列表左边添加元素，返回值标识增加元素后列表长度</span></span><br><span class="line">LPUSH key <span class="keyword">value</span> [<span class="keyword">value</span>]</span><br><span class="line"><span class="comment">-- RPUSH 命令用来向列表右边添加元素，返回值标识增加元素后列表长度</span></span><br><span class="line">RPUSH key <span class="keyword">value</span> [<span class="keyword">value</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; LPUSH num 4<br>(integer) 4</p>
</blockquote>
<hr>
<p>从列表两端弹出元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LPOP KEY</span><br><span class="line">RPOP KEY</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; LRANGE num 0 -1<br> “4”<br> “1”<br> “2”<br> “3”<br>127.0.0.1:6379&gt; LPOP num<br>“4”<br>127.0.0.1:6379&gt; LRANGE num 0 -1<br> “1”<br> “2”<br> “3”</p>
</blockquote>
<hr>
<p>获取列表的元素个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; LRANGE num 0 -1<br> “1”<br> “2”<br> “3”<br>127.0.0.1:6379&gt; LLEN num<br>(integer) 3</p>
</blockquote>
<hr>
<p>获取列表片段</p>
<p>⭐<strong>LRANGE 支持负索引， -1 表示最右元素，-2表示最右倒数第二元素</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LRANGE key <span class="keyword">start</span> stop</span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; LRANGE num 0 -1<br>“1”<br>“2”<br>“3”<br>127.0.0.1:6379&gt; LRANGE num 0 1<br>“1”<br>“2”</p>
</blockquote>
<hr>
<p>删除列表中指定的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LREM key count <span class="keyword">value</span></span><br><span class="line"><span class="comment">-- count删除几个，1就是从左删除一个 -1 就是从右删除一个</span></span><br><span class="line"><span class="comment">-- value 就是要删除的元素叫什么</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; LRANGE num 0 -1</p>
<p>“3”</p>
<p>“1”</p>
<p>“3”<br>127.0.0.1:6379&gt; LREM num -1 3<br>(integer) 1<br>127.0.0.1:6379&gt; LRANGE num 0 -1</p>
<p>“3”</p>
<p>“1”</p>
</blockquote>
<hr>
<p>获得/设置指定索引的元素值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LINDEX key index</span><br><span class="line">LSET key index <span class="keyword">value</span></span><br><span class="line"><span class="comment">-- 将列表类型当作数组来用,LINDEX 命令是必不可少的</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; LRANGE num 0 -1<br>  “8”<br>  “7”<br>  “6”<br>  “4”<br>  “3”<br>  “1”<br>  “8”<br>  “7”<br>  “6”<br>  “5”<br>  “4”<br>  “3”<br>  “1”<br>127.0.0.1:6379&gt; LINDEX num 0<br>“8”</p>
</blockquote>
<p><strong>LSET key index value</strong></p>
<blockquote>
<p>127.0.0.1:6379&gt; LINDEX num 0<br>“8”<br>127.0.0.1:6379&gt; LSET num 0 88<br>OK<br>127.0.0.1:6379&gt; LRANGE num 0 -1<br> “88”<br> “7”<br> “6”<br> “4”<br> “3”<br> “1”<br> “8”<br> “7”<br> “6”<br> “5”<br> “4”<br> “3”<br> “1”</p>
</blockquote>
<hr>
<p>只保留列表指定片段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LTRIM key <span class="keyword">start</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; LRANGE num 0 -1</p>
<p>“88”</p>
<p>“7”</p>
<p>“6”</p>
<p>“4”</p>
<p>“3”</p>
<p>“1”<br>127.0.0.1:6379&gt; ltrim num 0 2<br>OK<br>127.0.0.1:6379&gt; LRANGE num 0 -1</p>
<p>“88”</p>
<p>“7”</p>
</blockquote>
<hr>
<p>向列表中插入元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LINSERT key BEFORE<span class="operator">|</span> AFTER pivot <span class="keyword">value</span></span><br><span class="line"><span class="comment">-- 从左到右查找 pivot，before pivot之前 after pivot之后插入 value：插入的值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; LRANGE num 0 -1<br> “88”<br> “7”<br> “6”<br>127.0.0.1:6379&gt; LINSERT num before 88 66<br>(integer) 4<br>127.0.0.1:6379&gt; LRANGE num 0 -1<br> “66”<br> “88”<br> “7”<br> “6”</p>
</blockquote>
<hr>
<p>将元素从一个列表转到另一个列表R</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br><span class="line"><span class="comment">-- 先rpop 再lpush。</span></span><br><span class="line"><span class="comment">-- 从source右中弹出一个元素，左加入到 destination，并返回这个元素值。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; RPOPLPUSH num num1.1<br>“6”<br>127.0.0.1:6379&gt; RPOPLPUSH num num1.1<br>“7”<br>127.0.0.1:6379&gt; RPOPLPUSH num num1.1<br>“88”<br>127.0.0.1:6379&gt; RPOPLPUSH num num1.1<br>“66”</p>
</blockquote>
<h2 id="数据类型-集合类型"><a href="#数据类型-集合类型" class="headerlink" title="数据类型 - 集合类型"></a>数据类型 - 集合类型</h2><p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型在Redis内部是使用值为空的散列表（hash table）实现的，所以这些操作的时间复杂度都 是0(1)。</p>
<hr>
<p>增加/删除元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SADD key <span class="keyword">member</span> [<span class="keyword">member</span> …]</span><br><span class="line"><span class="comment">-- SADD 不存在创建。若元素已经存在则忽略，集合中不能有相同元素</span></span><br><span class="line">SREM key <span class="keyword">member</span> [<span class="keyword">member</span> …]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; sadd letter 1<br>(integer) 1<br>127.0.0.1:6379&gt; SADD letter 1<br>(integer) 0<br>127.0.0.1:6379&gt; SREM letter 1<br>(integer) 1<br>127.0.0.1:6379&gt; SREM letter 1<br>(integer) 0</p>
</blockquote>
<hr>
<p>获取集合中的所有元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; SADD letter 1 2 3 4<br>(integer) 4<br>127.0.0.1:6379&gt; SADD letter a b c d<br>(integer) 4<br>127.0.0.1:6379&gt; smembers letter<br> “1”<br> “b”<br> “3”<br> “c”<br> “4”<br> “d”<br> “2”<br> “a”</p>
</blockquote>
<hr>
<p>⭐集合间运算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 差集运算</span></span><br><span class="line">SDIFF key [key …] </span><br><span class="line"><span class="comment">-- 交集运算</span></span><br><span class="line">SINTER key [key …] </span><br><span class="line"><span class="comment">-- 并集运算</span></span><br><span class="line">SUNION key [key …]</span><br></pre></td></tr></table></figure>
<p>sdiff</p>
<blockquote>
<p>127.0.0.1:6379&gt; smembers letter<br> “1”<br> “b”<br> “3”<br> “c”<br> “4”<br> “d”<br> “2”<br> “a”<br>127.0.0.1:6379&gt; sadd letter1.0 1 2 3 4<br>(integer) 4<br>127.0.0.1:6379&gt; sdiff letter letter1.0<br> “d”<br> “b”<br> “a”<br> “c”</p>
</blockquote>
<p>inter</p>
<blockquote>
<p>127.0.0.1:6379&gt; SINTER letter letter1.0<br> “1”<br> “2”<br> “3”<br> “4”</p>
</blockquote>
<p>union</p>
<blockquote>
<p>127.0.0.1:6379&gt; sunion letter letter1.0<br> “d”<br> “a”<br> “2”<br> “1”<br> “3”<br> “4”<br> “b”<br> “c”</p>
</blockquote>
<hr>
<p>获得集合中元素个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; SCARD letter<br>(integer) 8</p>
</blockquote>
<hr>
<p>进行集合运算并将结果存储<br>集合间运算结果存储到 destination键 中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SDIFFSTORE destination key [key …]</span><br><span class="line">SINTERSTORE destination key [key …]</span><br><span class="line">SUNIONSTORE destination key [key …]</span><br></pre></td></tr></table></figure>

<hr>
<p>随机获得集合中的元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br><span class="line"><span class="comment">-- count 数字控制取出的数量</span></span><br><span class="line"><span class="comment">-- count 的正负控制是否会抽出重复，正不重复</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; SRANDMEMBER letter<br>“1”<br>127.0.0.1:6379&gt; SRANDMEMBER letter<br>“2”<br>127.0.0.1:6379&gt; SRANDMEMBER letter<br>“b”</p>
</blockquote>
<hr>
<p>从集合中弹出一个元素</p>
<p>⭐集合是随机弹出的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SPOP key</span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; SPOP letter<br>“c”<br>127.0.0.1:6379&gt; SPOP letter<br>“a”<br>127.0.0.1:6379&gt; SPOP letter<br>“2”</p>
</blockquote>
<h2 id="数据类型-有序集合类型"><a href="#数据类型-有序集合类型" class="headerlink" title="数据类型 - 有序集合类型"></a>数据类型 - 有序集合类型</h2><p>列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后， 访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。</p>
<p>有序集合类型是使用散列表和跳跃表（Skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度O(log(N))）。 </p>
<hr>
<p>增加元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ZADD key score <span class="keyword">member</span> [score <span class="keyword">member</span> …]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; ZADD xu 13 uu<br>(integer) 1<br>127.0.0.1:6379&gt; ZADD xu 13 kk<br>(integer) 1</p>
</blockquote>
<hr>
<p>查询元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> ZRANGE xu <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;akk&quot;</span><br><span class="line"><span class="number">2</span>) &quot;jie&quot;</span><br><span class="line"><span class="number">3</span>) &quot;uu&quot;</span><br><span class="line"><span class="number">4</span>) &quot;kk&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> ZRANGE xu <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) &quot;akk&quot;</span><br><span class="line"><span class="number">2</span>) &quot;11&quot;</span><br><span class="line"><span class="number">3</span>) &quot;jie&quot;</span><br><span class="line"><span class="number">4</span>) &quot;12&quot;</span><br><span class="line"><span class="number">5</span>) &quot;uu&quot;</span><br><span class="line"><span class="number">6</span>) &quot;13&quot;</span><br><span class="line"><span class="number">7</span>) &quot;kk&quot;</span><br><span class="line"><span class="number">8</span>) &quot;18&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p>获得元素分数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ZSCORE key <span class="keyword">member</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; ZSCORE xu akk<br>“11”</p>
</blockquote>
<hr>
<p>获取排名再某个范围的元素列表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按照分数大小 从小到大的顺序返回start-stop之间所有元素</span></span><br><span class="line">ZRANGE key <span class="keyword">start</span> stop[WITHSCORES]</span><br><span class="line">ZREVRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; ZRANGE xu 0 -1 withscores<br>“akk”<br>“11”<br>“jie”<br>“12”<br>“uu”<br>“13”<br>“kk”<br>“18”</p>
</blockquote>
<hr>
<p>获得指定分数范围的元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 该命令按照元素分数从小到大 的顺序返回分数在min和max之间（包含min和max）的元素</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT <span class="keyword">offset</span> count]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; ZRANGE xu 0 -1 withscores<br> “akk”<br> “11”<br> “jie”<br> “12”<br> “uu”<br> “13”<br> “kk”<br> “18”<br>127.0.0.1:6379&gt; ZRANGEBYSCORE xu 11 13<br> “akk”<br> “jie”<br> “uu”</p>
</blockquote>
<hr>
<p>增加/减少 某个元素的分数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ZINCRBY key increment <span class="keyword">member</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; ZINCRBY xu 8 akk<br>“19”<br>127.0.0.1:6379&gt; ZINCRBY xu -9 akk<br>“10”</p>
</blockquote>
<hr>
<p>获取集合元素中的数量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; ZCARD xu<br>(integer) 4<br>127.0.0.1:6379&gt; zrange xu 0 -1<br> “akk”<br> “jie”<br> “uu”<br> “kk”</p>
</blockquote>
<hr>
<p>获得指定分数范围內的元素个数 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; zrange xu 0 -1 withscores<br> “akk”<br> “10”<br> “jie”<br> “12”<br> “uu”<br> “13”<br> “kk”<br> “18”<br>127.0.0.1:6379&gt; ZCOUNT xu 10 14<br>(integer) 3</p>
</blockquote>
<hr>
<p>删除一个或多个元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ZREM key <span class="keyword">member</span> [<span class="keyword">member</span> …]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; ZCARD xu<br>(integer) 4<br>127.0.0.1:6379&gt; ZREM xu jie<br>(integer) 1<br>127.0.0.1:6379&gt; ZCARD xu<br>(integer) 3</p>
</blockquote>
<hr>
<p>按照排名范围删除元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ZREMRANGEBYRANK key <span class="keyword">start</span> stop</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.1:6379&gt; zrange xu 0 -1 withscores<br> “qq”<br> “1”<br> “ww”<br> “2”<br> “eee”<br> “3”<br> “akk”<br> “10”<br>127.0.0.1:6379&gt; ZREMRANGEBYRANK xu 2 3<br>(integer) 2<br>127.0.0.1:6379&gt; zrange xu 0 -1<br> “qq”<br> “ww”</p>
</blockquote>
<p>按照分数范围删除元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; zrange xu 0 -1 withscores<br>  “qq”<br>  “1”<br>  “ww”<br>  “2”<br>  “ee”<br>  “3”<br>  “rr”<br>  “4”<br>  “tt”<br>  “5”<br>127.0.0.1:6379&gt; ZREMRANGEBYSCORE xu 0 3<br>(integer) 3<br>127.0.0.1:6379&gt; zrange xu 0 -1 withscores<br> “rr”<br> “4”<br> “tt”<br> “5”</p>
</blockquote>
<hr>
<p>获得元素的排名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从小到大获取指定的排名 从0开始</span></span><br><span class="line">ZRANK key <span class="keyword">member</span></span><br><span class="line"><span class="comment">-- 从大到小获取指定的排名</span></span><br><span class="line">ZREVRANK key <span class="keyword">member</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>127.0.0.1:6379&gt; zrange xu 0 -1 withscores<br> “rr”<br> “4”<br> “tt”<br> “5”<br>127.0.0.1:6379&gt; ZRANK xu rr<br>(integer) 0<br>127.0.0.1:6379&gt; ZRANK xu tt<br>(integer) 1</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础(一)</title>
    <url>/183e61db.html</url>
    <content><![CDATA[<hr>
<ul>
<li>mysql 的默认引擎</li>
<li>mysql的知识点</li>
</ul>
<span id="more"></span>



<h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><h2 id="功能模块划"><a href="#功能模块划" class="headerlink" title="功能模块划"></a>功能模块划</h2><p><strong>Server层</strong></p>
<ul>
<li>连接器（管理接连，权限验证）</li>
<li>查询缓存</li>
<li>分析器（词法分析，语法分析）</li>
<li>优化器（执行计划生成，索引选择）</li>
<li>执行器（操作引擎，返回结果）</li>
<li>存储过程，触发器，视图等等。</li>
</ul>
<p><strong>存储引擎层</strong></p>
<ul>
<li>数据的存储和提取。</li>
</ul>
<h2 id="mysql-的默认引擎"><a href="#mysql-的默认引擎" class="headerlink" title="mysql 的默认引擎"></a>mysql 的默认引擎</h2><blockquote>
<p>MySQL 默认存储引擎是 InnoDB ，创建表的时候，如不指定引擎类型，默认InnoDB</p>
</blockquote>
<h2 id="mysql的小知识点"><a href="#mysql的小知识点" class="headerlink" title="mysql的小知识点"></a>mysql的小知识点</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><ol>
<li>连接器负责对客户端建立链接，获取权限，维持和管理连接<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h ip <span class="operator">-</span>P port <span class="operator">-</span>u <span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure></li>
<li>账户密&amp;码正确，连接器查询权限获得权限，自此，断开连接之前都是该权限。</li>
</ol>
<p><strong>完成连接后的小知识点</strong></p>
<ul>
<li>连接完成后，没有动作，即 sleep 处于空闲状态。可以使用 show processlist 查看</li>
<li>默认断开时间 8 小时 由 wait_timeout 控制，当断开后继续执行，抛出错误信息 lost connection 需要重新连接。</li>
<li>长连接：客户持续有请求，则一直使用同一个连接</li>
<li>短连接：每次执行完很少几次查询就会断开，下次查询重新建立</li>
<li>减少建立连接，尽量使用长连接。</li>
</ul>
<p><strong>若都是长连接，MySQL 占用内存涨的很快，因为 MySQL 执行过程中临时使用的内存管理在连接对象里面，要在断开连接时才会释放。长期积累 可能会 OOM MySQL 异常重启。</strong></p>
<ul>
<li>定期断开长连接。</li>
<li>使用mysql_reset_connection来重新初始化连接资源</li>
</ul>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><ol>
<li>MySQL建立连接后，执行sql</li>
<li>执行前，判断之前是否执行过</li>
<li>执行过，通过sql(key)直接返回数据（value）</li>
<li>没有执行过，查询出结果，并放到缓存中</li>
<li>多命中缓存，效率高</li>
</ol>
<p><strong>大多数情况不建议使用查询缓存，因为可能弊大于利</strong></p>
<ol>
<li>缓存需要语句完全相等，包括参数。</li>
<li>表更新后就会失效 因此，只有在表更新频率不高，查询语句完全一致的情况下，可以手动开启缓存，其他一律关闭。 </li>
</ol>
<p><strong>注意：mysql8之后，取消了缓存功能。</strong></p>
<p>可以使用 <em><strong>query_cache_type</strong></em> 设置成 <em><strong>DEMAND</strong></em> 来进行按需缓存 通过 SQL_CACHE 显示执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure>
<p><strong>可是使用 show variables 来查看服务器配置信息。</strong></p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><ol>
<li>未命中缓存，进入分析器，进行查询。</li>
<li>分析器首先做词法分析，它要知道这个语句中的单词是什么意思</li>
<li>分析器再进行语法分析，词法分析结果，语法分析器根据语法规则判断 SQL 语句是否满足 SQL 语法</li>
<li>表名和列名在分析语法时就已经确定过了</li>
</ol>
<p><strong>tips:</strong> You have an error in your SQL syntax  关注 use near 的解析</p>
<p><strong>分析器干两件事：</strong></p>
<ol>
<li>解析语句，生成解析树 </li>
<li>检查语句中的关键词，表，字段是否存在</li>
</ol>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</p>
<p>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。<br><strong>区别:</strong></p>
<ol>
<li>执行效率不同</li>
<li>尽可能扫描少的数据库行纪录</li>
</ol>
<p><em><strong>优化器是在表里面有多个索引的时候，决定使用哪个索引；</strong></em></p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><ul>
<li><p>判断是否对 表 T 有执行查询的权限</p>
</li>
<li><p>权限验证不仅再执行器这里，再分析器知道要做什么之后，也会做一次权限校验叫precheck</p>
</li>
<li><p>precheck 无法对运行时涉及到的表进行权限验证所以再执行器这里还需要验证。</p>
</li>
<li><p>判断拥有权限后，根据表定义的引擎，使用执行器使用对应引擎提供的接口。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>递归（Recurtion）</title>
    <url>/8bf709ac.html</url>
    <content><![CDATA[<hr>
<ul>
<li>递归的本质和基本实现</li>
<li>递归的实例</li>
</ul>
<span id="more"></span>

<h1 id="递归（Recurtion）"><a href="#递归（Recurtion）" class="headerlink" title="递归（Recurtion）"></a>递归（Recurtion）</h1><h2 id="递归的本质和基本实现形式"><a href="#递归的本质和基本实现形式" class="headerlink" title="递归的本质和基本实现形式"></a>递归的本质和基本实现形式</h2><h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a><strong>什么是递归</strong></h3><ul>
<li>函数自身调用自身</li>
<li>通过函数体来进行循环</li>
<li>以自相似的方法重复进行的过程</li>
</ul>
<h3 id="计算-n-n的阶乘"><a href="#计算-n-n的阶乘" class="headerlink" title="计算 n! n的阶乘"></a><strong>计算 n! n的阶乘</strong></h3><blockquote>
<p>n! = 1 * 2 * 3 * 4 * n</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= N; n++)&#123;</span><br><span class="line">            <span class="keyword">int</span> fact = factorial(n);</span><br><span class="line">            System.out.println(n + <span class="string">&quot; 的阶乘值是： &quot;</span> + fact);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> factorial(n-<span class="number">1</span>) * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 的阶乘值是： 1</span><br><span class="line">1 的阶乘值是： 1</span><br><span class="line">2 的阶乘值是： 2</span><br><span class="line">3 的阶乘值是： 6</span><br><span class="line">4 的阶乘值是： 24</span><br><span class="line">5 的阶乘值是： 120</span><br></pre></td></tr></table></figure>
<h3 id="图解-阶乘"><a href="#图解-阶乘" class="headerlink" title="图解 阶乘"></a>图解 阶乘</h3><p><img src="/8bf709ac/image-20211122230840070.png" alt="image-20211122230840070"></p>
<p>递归分为了两个部分</p>
<ul>
<li>解析路径部分 即： factorial(6) 到 6 * (5 * (4 * (3 * (2 * factorial(1)))) 目的展开路径。</li>
<li>计算结果部分 即：6 * (5 * (4 * (3 * (2 * 1))) 到 6 * 120  结果叠加回去 最后得到 720</li>
</ul>
<h3 id="什么时候用递归-什么时候用递推"><a href="#什么时候用递归-什么时候用递推" class="headerlink" title="什么时候用递归 什么时候用递推"></a>什么时候用递归 什么时候用递推</h3><p>递推：如阶乘明显算5的阶乘 可以用递推 他的推导路径一目了然 1 * 2 * 3 * 4 … * n 等等 用 for 即可<br>递归：当推导路径不明确的时候可以使用递归，如计算一棵树的时候，取得某些节点符合条件节点，但是树并不一定就是平衡二叉树，不能确定他长什么样子的时候就可以使用递归。先探索树的路径，然后返回结果。</p>
<h3 id="递归的三个关键"><a href="#递归的三个关键" class="headerlink" title="递归的三个关键"></a>递归的三个关键</h3><p>1.定义需要递归的问题（重叠子问题）<br>2.确定递归边界<br>3.保护和还原现场</p>
<h3 id="保护和还原现场"><a href="#保护和还原现场" class="headerlink" title="保护和还原现场"></a>保护和还原现场</h3><blockquote>
<p>当使用了全局变量的时候，才退出当前方法的时候要还原，因为这是所有重叠方法都需要使用的。<br>相对而言，局部变量和参数。就不需要还原了，因为每一次递归方法的时候他都会创建一个新的，重写方法之间没有关联。</p>
</blockquote>
<h3 id="递归模板"><a href="#递归模板" class="headerlink" title="递归模板"></a>递归模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法名</span><br><span class="line">	终止条件</span><br><span class="line">	本层处理</span><br><span class="line">	递归子问题</span><br><span class="line">	还原现场</span><br></pre></td></tr></table></figure>

<h2 id="递归实例"><a href="#递归实例" class="headerlink" title="递归实例"></a>递归实例</h2><p><a href="https://leetcode-cn.com/problems/subsets/">78.子集</a></p>
<ul>
<li>子集是指数型的枚举/递归(元素的 选择与不选择 2^n 元素个数n)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 作为最后的返回值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; set = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        findSubsets(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findSubsets</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 设置边界</span></span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(set));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本层处理</span></span><br><span class="line">        <span class="comment">// 本层两种处理 选择/不选择</span></span><br><span class="line">        <span class="comment">// 不选择</span></span><br><span class="line">        findSubsets(nums,index+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择</span></span><br><span class="line">        set.add(nums[index]);</span><br><span class="line">        findSubsets(nums,index+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 还原现场</span></span><br><span class="line">        set.remove(set.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
